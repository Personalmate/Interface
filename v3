create or replace view DB_CORE_PRD.PSG.VW_NEW_INGESTION_STATUS_LAST_14_DAYS(
	TABLE_NAME,
	FIRST_RUN_DATE,
	RUN_DATE,
	RUN_STATUS
) as
 
WITH
 
  /* find all “new” tables that are in the ingestion view but not in your static table */
 
  NEW_TABLES AS (
 
    SELECT DISTINCT VS.TABLE_NAME
 
    FROM   DB_CORE_PRD.PSG.VW_CORE_INGESTION_SF_LOAD_STATUS VS
 
    WHERE  NOT EXISTS (
 
      SELECT 1
 
      FROM   DB_CORE_PRD.PSG.OPS_TEAM_STATIC_INTERFACE_TABLE SIT
 
      WHERE  SIT.TABLE_NAME = VS.TABLE_NAME
 
    )
 
  ),
 
  /* generate the calendar of the last 14 days (including today) */
 
  LAST_14_DAYS AS (
 
    SELECT DAY_DT
 
    FROM   DB_CORE_PRD.PSG.TIME_DAY_DM
 
    WHERE  DAY_DT BETWEEN DATEADD(DAY, -13, CURRENT_DATE()) AND CURRENT_DATE()
 
  ),
 
    /* for each new table the first run date is taken */
 
 FIRST_RUN as (
  select TABLE_NAME,
         min(cast(START_DT as date)) as FIRST_RUN_DATE  
  from DB_CORE_PRD.PSG.VW_CORE_INGESTION_SF_LOAD_STATUS
  where PROCESS_STATUS = 'COMPLETE'
    and TABLE_NAME in (select TABLE_NAME from NEW_TABLES)
  group by TABLE_NAME
),
 
  /* for each new table + day, pick the latest run (if any) in that 14-day window */
 
  LATEST_RUN_PER_DAY AS (
 
    SELECT
 
      TABLE_NAME,
 
      CAST(DATE_TRUNC('DAY', START_DT) AS DATE)   AS RUN_DATE,
 
      PROCESS_STATUS,
 
      ROW_NUMBER() OVER (
 
        PARTITION BY TABLE_NAME,
 
                     CAST(DATE_TRUNC('DAY', START_DT) AS DATE)
 
        ORDER BY START_DT DESC
 
      )                                           AS RN
 
    FROM   DB_CORE_PRD.PSG.VW_CORE_INGESTION_SF_LOAD_STATUS
 
    WHERE  TABLE_NAME IN (SELECT TABLE_NAME FROM NEW_TABLES)
 
      AND  CAST(START_DT AS DATE) BETWEEN DATEADD(DAY, -13, CURRENT_DATE())
 
                                     AND CURRENT_DATE()
 
  )
 
SELECT
 
  NT.TABLE_NAME,
 
  FR.FIRST_RUN_DATE,
 
  D.DAY_DT                      AS RUN_DATE,
 
  CASE
 
    WHEN LR.PROCESS_STATUS = 'COMPLETE' THEN 'Green'
 
    WHEN LR.PROCESS_STATUS = 'ERROR'    THEN 'Red'
 
    ELSE 'Yellow'
 
  END                            AS RUN_STATUS
 
FROM   NEW_TABLES NT
 
CROSS JOIN LAST_14_DAYS D
 
LEFT JOIN LATEST_RUN_PER_DAY LR
 
  ON  LR.TABLE_NAME = NT.TABLE_NAME
 
  AND LR.RUN_DATE   = D.DAY_DT
 
  AND LR.RN         = 1
 
  LEFT  JOIN FIRST_RUN fr
  ON fr.TABLE_NAME = nt.TABLE_NAME
 
  ORDER BY NT.TABLE_NAME, d.DAY_DT;




create or replace view DB_CORE_PRD.PSG.VW_CORE_INGESTION_SF_LOAD_STATUS(
	JOB_TAG,
	PIPELINE,
	TABLE_NAME,
	INTERFACE_SOURCE,
	START_DT,
	END_DT,
	PROCESS_STATUS,
	LATEST_RUN_IND
) COMMENT='lATEST AND HISTORICAL RUN details OF CORE INGESTION FRAMEWORK'
 as
SELECT INTERFACE.AUDIT_JOB_GUID 		AS JOB_TAG
,INTERFACE.PIPELINE 					AS PIPELINE
,INTERFACE.TABLE_NAME 					AS TABLE_NAME
,INTERFACE.INTERFACE_SOURCE 			AS INTERFACE_SOURCE
,INTERFACE.START_TIME 					AS START_DT
,INTERFACE.END_TIME 					AS END_DT
,JOB_STATUS.STATUS 						AS PROCESS_STATUS
,CASE WHEN (ROW_NUMBER() OVER (PARTITION BY INTERFACE.PIPELINE ORDER BY INTERFACE.START_TIME DESC))=1 
	  THEN 1 ELSE 0 
  END  									AS LATEST_RUN_IND
FROM (
SELECT 
AUDIT_JOB_GUID
,PIPELINE
,SUBSTR(PIPELINE,pos_last_slash+1,(pos_json)-(pos_last_slash+1)) TABLE_NAME
,UPPER(REPLACE((SUBSTR(PIPELINE,pos_first_slash+1,(pos_third_slash)-(pos_first_slash+1))),'/',' - ' )) INTERFACE_SOURCE
,START_TIME
,END_TIME
FROM 
(
               SELECT
       PIPELINE
       ,AUDIT_JOB_GUID
       ,REGEXP_INSTR(PIPELINE,'/',1,1) pos_first_slash
       ,REGEXP_INSTR(PIPELINE,'/',1,3) pos_third_slash
       ,REGEXP_INSTR(PIPELINE,'[/][^/]*$',1) pos_last_slash
       ,REGEXP_INSTR(PIPELINE,'.json',1) pos_json
       ,START_TIME
       ,END_TIME
    FROM (
            SELECT 
               PIPELINE,AUDIT_JOB_GUID
               ,MIN(STARTED_AT) START_TIME
               ,MAX(STARTED_AT) END_TIME 
               FROM DB_CORE_PRD.PMD.AUDIT_INGESTION_LOG
            WHERE 1=1
               AND DATE_TRUNC('DAY', STARTED_AT) > current_date - 60  ----------->> UPDATE date
               and pipeline <>'None'
            GROUP BY PIPELINE,AUDIT_JOB_GUID
         )
     )
) INTERFACE
INNER JOIN 
(
    SELECT AUDIT_JOB_GUID
        , PIPELINE
        , CASE WHEN SUM(STAT) = 0 THEN 'COMPLETE' ELSE 'ERROR' END STATUS 
    FROM (
          SELECT AUDIT_JOB_GUID
               , PIPELINE
               , LOG_LEVEL_NAME
               , CASE WHEN LOG_LEVEL_NAME = 'INFO' THEN 0 WHEN LOG_LEVEL_NAME = 'ERROR' THEN 1 ELSE 0 END AS STAT
          FROM DB_CORE_PRD.PMD.AUDIT_INGESTION_LOG
          WHERE 1=1
          AND DATE_TRUNC('DAY', STARTED_AT) > current_date - 60    ----------->> UPDATE date
          GROUP BY AUDIT_JOB_GUID, PIPELINE, LOG_LEVEL_NAME
         )
    WHERE 1=1
    and pipeline <>'None'
    GROUP BY AUDIT_JOB_GUID, PIPELINE
) JOB_STATUS
ON INTERFACE.AUDIT_JOB_GUID = JOB_STATUS.AUDIT_JOB_GUID
ORDER BY INTERFACE.TABLE_NAME, START_TIME DESC 
;
